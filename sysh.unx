/* sysh.unx
   The header file for the UNIX system dependent routines.

   Copyright (C) 1991, 1992 Ian Lance Taylor

   This file is part of the Taylor UUCP package.

   This program is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   The author of the program may be contacted at ian@airs.com or
   c/o AIRS, P.O. Box 520, Waltham, MA 02254.

   $Log$
   Revision 1.33  1992/02/09  02:41:58  ian
   Added HAVE_DUP2 configuration parameter and dup2 emulation function

   Revision 1.32  1992/02/08  23:34:41  ian
   If we have neither getcwd nor getwd, fork /bin/pwd to get the cwd

   Revision 1.31  1992/02/08  20:02:36  ian
   Added HAVE_SETRET configuration option for systems without setjmp

   Revision 1.30  1992/02/08  03:54:18  ian
   Include <string.h> only in <uucp.h>, added 1992 copyright

   Revision 1.29  1992/01/15  21:06:11  ian
   Mike Park: some systems can't include <sys/time.h> and <time.h> together

   Revision 1.28  1992/01/15  19:40:35  ian
   Mike Park: handle HAVE_UNION_WAIT correctly and completely

   Revision 1.27  1992/01/15  07:06:29  ian
   Set configuration directory in Makefile rather than sysdep.h

   Revision 1.26  1992/01/14  04:18:47  ian
   Chip Salzenberg: added HAVE_USLEEP configuration parameter

   Revision 1.25  1992/01/13  19:59:29  ian
   Define LIBDIR in Makefile rather than in sysh.unx

   Revision 1.24  1992/01/13  05:55:59  ian
   Touched up a few comments

   Revision 1.23  1992/01/13  05:53:04  ian
   Mike Park: added HAVE_WAITPID and HAVE_WAIT4 configuration parameters

   Revision 1.22  1992/01/11  17:11:11  ian
   Hannu Strang: avoid compiler bug by not using -> in address constant

   Revision 1.21  1992/01/04  21:43:24  ian
   Chip Salzenberg: added ALLOW_FILENAME_ARGUMENTS to permit them

   Revision 1.20  1991/12/29  00:55:23  ian
   Monty Solomon: added HAVE_UNION_WAIT

   Revision 1.19  1991/12/28  17:08:47  ian
   John Theus: offer HAVE_GETWD as an alternative to using getcwd

   Revision 1.18  1991/12/28  07:01:15  ian
   Added HAVE_FTIME configuration option

   Revision 1.17  1991/12/22  22:14:19  ian
   Monty Solomon: added HAVE_UNISTD_H configuration parameter

   Revision 1.16  1991/12/19  04:25:57  ian
   Terry Gardner: configuration parameter to not use both NONBLOCK and NDELAY

   Revision 1.15  1991/12/17  07:09:58  ian
   Record statistics in fractions of a second

   Revision 1.14  1991/12/11  04:21:37  ian
   Arne Ludwig: merge in Arne Ludwig's patches for V2 and BNU style logging

   Revision 1.13  1991/12/09  19:07:07  ian
   Richard Todd: add HAVE_V2_LOCKFILES--binary number in lock file

   Revision 1.12  1991/11/30  23:28:26  ian
   Marty Shannon: some systems need a fake version of the rename system call

   Revision 1.11  1991/11/26  01:45:42  ian
   Marty Shannon: configuration option to not include <sys/wait.h>

   Revision 1.10  1991/11/24  04:15:13  ian
   Removed extraneous comment left by last revision

   Revision 1.9  1991/11/21  21:49:38  ian
   Brian Campbell: define all macros to avoid compiler warnings

   Revision 1.8  1991/11/21  21:07:46  ian
   Brian Campbell: offer ltrunc as an alternative to ftruncate

   Revision 1.7  1991/11/10  19:24:22  ian
   Added pffile protocol entry point for file level control

   Revision 1.6  1991/11/08  22:52:34  ian
   Brian Campbell: only include <sys/time.h> and <sys/ioctl.h> when needed

   Revision 1.5  1991/11/08  22:11:45  ian
   Brian Campbell: allow sigsetjmp as configuration option

   Revision 1.4  1991/11/07  19:32:28  ian
   Chip Salzenberg: allow LOCKDIR, and check that locking process exists

   Revision 1.3  1991/09/19  16:15:58  ian
   Chip Salzenberg: configuration option for permitting execution via sh

   Revision 1.2  1991/09/19  03:06:04  ian
   Chip Salzenberg: put BNU temporary files in system's directory

   Revision 1.1  1991/09/10  19:45:50  ian
   Initial revision

   */

#ifndef SYSH_UNX_H

#define SYSH_UNX_H

#ifdef __GNUC__
 #pragma once
#endif

/* The name of the default spool directory.  This may be overridden by
   the ``spool'' command in the configuration file.  */
#define SPOOLDIR "/usr/spool/uucp"

/* The name of the default public directory.  This may be overridden
   by the ``pubdir'' command in the configuration file.  Also, a
   particular system may be given a specific public directory by
   using the ``pubdir'' command in the system file.  */
#define PUBDIR "/usr/spool/uucppublic"

/* If you use other programs that also access devices, the other
   programs must agree on whether a device is locked.  This is
   typically done by creating a lock file in a specific directory.
   The lock file is named LCK.. followed by the name of the device.
   Remote systems are also locked the same way.  If the LOCKDIR macro
   is defined, these lock files will be placed in the named directory;
   otherwise they will be placed in the default spool directory.  On
   some BNU systems the lock files are placed in /etc/locks.  */
/* #define LOCKDIR "/etc/locks" */

/* You must also specify the format of the lock files by setting
   exactly one of the following macros to 1.  The BNU style is to
   write the locking process ID in ASCII, taking up ten bytes with a
   following newline.  The V2 style is to write the locking process ID
   as four binary bytes in the host byte order.  Check an existing
   lock file to decide which of these choices is more appropriate.  */
#define HAVE_V2_LOCKFILES 0
#define HAVE_BNU_LOCKFILES 1

#if HAVE_TAYLOR_LOGGING

/* The default log file when using HAVE_TAYLOR_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``logfile''
   command in the configuration file.  */
#define LOGFILE "/usr/spool/uucp/Log"

/* The default statistics file when using HAVE_TAYLOR_LOGGING.  When
   using HAVE_TAYLOR_CONFIG, this may be overridden by the
   ``statfile'' command in the configuration file.  */
#define STATFILE "/usr/spool/uucp/Stats"

/* The default debugging file when using HAVE_TAYLOR_LOGGING.  When
   using HAVE_TAYLOR_CONFIG, this may be overridden by the
   ``debugfile'' command in the configuration file.  */
#define DEBUGFILE "/usr/spool/uucp/Debug"

#endif /* HAVE_TAYLOR_LOGGING */

#if HAVE_V2_LOGGING

/* The default log file when using HAVE_V2_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``logfile''
   command in the configuration file.  */
#define LOGFILE "/usr/spool/uucp/LOGFILE"

/* The default statistics file when using HAVE_V2_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``statfile''
   command in the configuration file.  */
#define STATFILE "/usr/spool/uucp/SYSLOG"

/* The default debugging file when using HAVE_V2_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``debugfile''
   command in the configuration file.  */
#define DEBUGFILE "/usr/spool/uucp/DEBUG"

#endif /* HAVE_V2_LOGGING */

#if HAVE_BNU_LOGGING

/* The default log file when using HAVE_BNU_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``logfile''
   command in the configuration file.  The first %s in the string will
   be replaced by the program name (e.g. uucico); the second %s will
   be replaced by the system name (if there is no appropriate system,
   "ANY" will be used).  No other '%' character may appear in the
   string.  */
#define LOGFILE "/usr/spool/uucp/.Log/%s/%s"

/* The default statistics file when using HAVE_BNU_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``statfile''
   command in the configuration file.  */
#define STATFILE "/usr/spool/uucp/.Admin/xferstats"

/* The default debugging file when using HAVE_BNU_LOGGING.  When using
   HAVE_TAYLOR_CONFIG, this may be overridden by the ``debugfile''
   command in the configuration file.  */
#define DEBUGFILE "/usr/spool/uucp/.Admin/audit.local"

#endif /* HAVE_BNU_LOGGING */

/* The default command path, specifying which directories the commands
   to be executed must be located in.  */
#define CMDPATH "/bin /usr/bin /usr/local/bin"

/* ISC 2.02, and probably other systems, does not have the include
   file <sys/wait.h>.  On such a system, set the following macro to 0
   to avoid trying to include it.  */
#define HAVE_SYSWAIT_H 1

/* The type pid_t is the type of a process identifier.  It is normally
   defined in <sys/types.h>; if it is not defined there, uncomment the
   following line and set it to the correct type.  This is the type
   returned by the fork(2) function and the getpid(2) function.  */
/* #define PID_T int */

/* The type uid_t is the type of a user identifier.  It is normally
   defined in <sys/types.h>; if it is not defined there, uncomment the
   following line and set it to the correct type.  This is the type
   returned by the getuid(2) function; on System V it is often
   unsigned short.  */
/* #define UID_T short */

/* The type off_t is the return value of lseek(2).  It is sometimes
   defined in <sys/types.h>; if it is not define there, uncomment the
   following line and set it to the correct type.  */
/* #define OFF_T long */

/* If you want to be able to use a default for the system name without
   specifying it with the ``nodename'' command in the configuration
   file, one of the following macros must be set to 1.  Set
   HAVE_GETHOSTNAME to 1 if you have the gethostname call.  Set
   HAVE_UNAME to 1 if you have the uname call.  */
#define HAVE_GETHOSTNAME 1
#define HAVE_UNAME 0

/* Exactly one of the following macros must be set to 1.

   HAVE_BSD_TTY -- Use the 4.2BSD tty routines
   HAVE_SYSV_TERMIO -- Use the System V termio routines
   HAVE_POSIX_TERMIOS -- Use the POSIX termios routines
   */
#define HAVE_BSD_TTY 1
#define HAVE_SYSV_TERMIO 0
#define HAVE_POSIX_TERMIOS 0

/* On QNX 4, and possibly other systems, including <sys/ioctl.h>
   interferes with <termios.h>.  On such a system, set the following
   macro to 0 to avoid include <sys/ioctl.h>.  On any normal system,
   or any system which does not use HAVE_POSIX_TERMIOS, do not change
   this line.  */
#define HAVE_SYSIOCTL_H 1

/* On Sun3/280 OS 3.2, and possibly other systems, <sys/time.h>
   includes <time.h> and <time.h> does not permit multiple inclusion.
   On such a system, set the following macro to 0.  This does not
   override the value of HAVE_TIME_H.  */
#define HAVE_SYS_TIME_AND_TIME_H 1

/* On HPUX 8.0, and possibly other systems, fcntl returns an error if
   you try to specify both O_NONBLOCK and O_NDELAY.  If you get an
   invalid argument from fcntl, this may be the problem.  If this
   macro is non zero, it will be used as the argument to fcntl to
   force a file descriptor to not block.  */
#define USE_FOR_UNBLOCKED 0

/* There are various possibilities for routines to sleep for less than
   a second.  If you are using HAVE_BSD_TTY, these will be used to
   improve CPU performance when reading from a serial line.  They are
   also used to sleep half a second in a chat script.  Set either zero
   or one of these to 1.

   HAVE_SETITIMER -- Use the BSD setitimer routine
   HAVE_NAPMS -- Use napms which takes a number of milliseconds to sleep
   HAVE_NAP -- Use nap which takes a number of milliseconds to sleep
   HAVE_USLEEP -- Use usleep which takes a number of microseconds to sleep
   */
#define HAVE_SETITIMER 1
#define HAVE_NAPMS 0
#define HAVE_NAP 0
#define HAVE_USLEEP 0

/* Set HAVE_SIGSETJMP to 1 if you have the sigsetjmp and siglongjmp
   calls, and they should be used to jump out of a signal handler.
   Otherwise if you don't have setjmp and longjmp but you do have
   setret and longret, set HAVE_SETRET to 1.  */
#define HAVE_SIGSETJMP 1
#define HAVE_SETRET 0

/* Set HAVE_EUID to 1 if it makes sense to call setuid (geteuid ()).
   This is mainly done to avoid running with root permissions, which
   make locking complex.  Setting it to 1 will actually do no harm
   even if the call fails.  */
#define HAVE_EUID 1

/* Set HAVE_FTRUNCATE to 1 if you have the ftruncate call which
   truncates an open file to a specified length.  Alternatively, set
   HAVE_LTRUNC to 1 if you have the ltrunc call which also truncates a
   file but takes different arguments.  */
#define HAVE_FTRUNCATE 1
#define HAVE_LTRUNC 0

/* Set HAVE_RENAME to 1 if you have the rename call which renames a
   file.  If this is set to 0, the program will use the link and
   unlink calls.  */
#define HAVE_RENAME 1

/* Exactly one of the following macros must be set to 1.  The exact
   format of the spool directories is explained in sys3.unx.

   SPOOLDIR_V2 -- Use a Version 2 (original UUCP) style spool directory
   SPOOLDIR_BSD42 -- Use a BSD 4.2 style spool directory
   SPOOLDIR_BSD43 -- Use a BSD 4.3 style spool directory
   SPOOLDIR_BNU -- Use a BNU (HDB) style spool directory
   SPOOLDIR_ULTRIX -- Use an Ultrix style spool directory
   SPOOLDIR_TAYLOR -- Use a new style spool directory

   If you are not worried about compatibility with a currently running
   UUCP, use SPOOLDIR_TAYLOR.  */
#define SPOOLDIR_V2 0
#define SPOOLDIR_BSD42 0
#define SPOOLDIR_BSD43 0
#define SPOOLDIR_BNU 0
#define SPOOLDIR_ULTRIX 0
#define SPOOLDIR_TAYLOR 1

/* Set exactly one of the following macros to 1 to determine how
   directories should be read.  If you have do not have the
   opendir/readdir/closedir functions, I recommend that you find Doug
   Gwyn's public domain implementation (among other places, it is
   available from uunet in ~/packages/gnu/dirent.tar.Z).  However, if
   you have the original Unix directory format (a two byte inode
   followed by a 14 byte filename) you can set HAVE_OLD_DIRECTORIES to
   1 to use a somewhat simplistic emulation.

   HAVE_POSIX_DIRENT -- Use POSIX (and System V) dirent structure
   HAVE_BSD_DIRECT -- Use BSD direct structure
   HAVE_OLD_DIRECTORIES -- Read old style directories directly.  */
#define HAVE_POSIX_DIRENT 1
#define HAVE_BSD_DIRECT 0
#define HAVE_OLD_DIRECTORIES 0

/* If you have the dup2 call, set HAVE_DUP2 to 1.  */
#define HAVE_DUP2 0

/* If the system supports file names longer than 14 characters,
   set HAVE_LONG_NAMES to 1.  */
#define HAVE_LONG_NAMES 1

/* Define the mail program to use.  This will be called with the user
   name to send mail to as the only argument, and the mail to send
   will be written to standard input.  */
#define MAIL_PROGRAM "/usr/ucb/mail"

/* Define the echo program to use.  This will be called to expand
   wildcard specifications.  */
#define ECHO_PROGRAM "/bin/echo"

/* The uucico daemon, when talking to another copy of itself, can
   check the amount of free disk space to make sure there is enough
   room before accepting a transferred file.  Unfortunately, there is
   no standard way to determine the amount of free disk space.  One of
   the following macros must be set to 1 in order for the amount of
   free space to be discovered.  This is only helpful when talking to
   another instance of Taylor UUCP, and in any case setting all the
   choices to 0 will do no real harm, it will just mean that the
   package will not check whether the disk will be filled before
   accepting a file.

   HAVE_ULTRIX_STATFS -- Use the statfs call as found on Ultrix systems
   HAVE_SCO_STATFS -- Use the statfs call as found on SCO Unix
   HAVE_USTAT -- Use the System V ustat call  */
#define HAVE_ULTRIX_STATFS 1
#define HAVE_SCO_STATFS 0
#define HAVE_USTAT 0

/* If you have the gettimeofday function which takes a pointer to a
   timeval structure and fills in the time in seconds and
   microseconds, set HAVE_GETTIMEOFDAY to 1.  Otherwise, if you have
   the ftime call which takes a pointer to a timeb structure and fills
   in the time in seconds and milliseconds, set HAVE_FTIME to 1.
   Otherwise, if you have the times function which returns the time
   since some epoch in fractions of a second, set HAVE_TIMES to 1.  If
   you set HAVE_TIMES to 1 you must also set TIMES_TICK to the
   fraction of a second which times returns (for example, if times
   returns 100ths of a second TIMES_TICK should be set to 100).  On a
   true POSIX system TIMES_TICK may simply be defined as CLK_TCK.  On
   some systems the environment variable HZ is what you want for
   TIMES_TICK, but on some other systems HZ has the wrong value; check
   the man page.  The tstuu program requires the times function, and
   will use TIMES_TICK even if HAVE_TIMES is set to 0; if you plan to
   compile tstuu, set TIMES_TICK correctly even if you do not set
   HAVE_TIMES.  */
#define HAVE_GETTIMEOFDAY 1
#define HAVE_FTIME 0
#define HAVE_TIMES 0
#define TIMES_TICK CLK_TCK

/* If you have the POSIX getcwd function to get the current directory,
   set HAVE_GETCWD to 1.  Otherwise, if you have the BSD getwd
   function, set HAVE_GETWD to 1.  Otherwise, set both to 0 and make
   sure that PWD_PROGRAM is the name of a program that will print the
   current working directory (followed by a newline) on stdout.  */
#define HAVE_GETCWD 1
#define HAVE_GETWD 0
#define PWD_PROGRAM "/bin/pwd"

/* The NeXT, and possibly other systems, requires the argument to the
   wait function to be a pointer to a variable of type union wait.  On
   such systems, set HAVE_UNION_WAIT to 1.  Note that on a POSIX
   system, HAVE_UNION_WAIT should be 0.  */
#define HAVE_UNION_WAIT 0

/* If you have the POSIX waitpid system call, set HAVE_WAITPID to 1.
   Otherwise, if you have the wait4 system call, which also lets you
   specify a particular pid to wait for, set HAVE_WAIT4 to 1.  These
   are only used by the tstuu test program, and even for that setting
   them both to 0 will not have seriously bad effects.  */
#define HAVE_WAITPID 1
#define HAVE_WAIT4 0

/* The default amount of free space to require for systems that do
   not specify an amount with the ``free-space'' command.  */
#define DEFAULT_FREE_SPACE (50000)

/* It is possible for an execute job to request to be executed using
   /bin/sh(1), rather than execve(2).  This is such a security risk,
   it is being disabled by default; to allow such jobs, set the
   following macro to 1.  */
#define ALLOW_SH_EXECUTION 0

/* If a command executed on behalf of a remote system takes a filename
   as an argument, a security breach may be possible (note that on my
   system neither of the default commands, rmail and rnews, take
   filename arguments).  If you set ALLOW_FILENAME_ARGUMENTS to 0, all
   arguments to a command will be checked; if any argument
   1) starts with ../
   2) contains the string /../
   3) begins with a / but does not name a file that may be sent or
      received (according to the specified ``remote-send'' and
      ``remote-receive'')
   the command will be rejected.  By default, any argument is
   permitted. */
#define ALLOW_FILENAME_ARGUMENTS 1

/*

  THERE ARE NO MORE CONFIGURATION PARAMETERS.

  */

/* Make sure the defines do not conflict.  */

#if HAVE_V2_LOCKFILES + HAVE_BNU_LOCKFILES != 1
 #error LOCKFILES define not set or duplicated
#endif

#if HAVE_BSD_TTY + HAVE_SYSV_TERMIO + HAVE_POSIX_TERMIOS != 1
 #error Terminal routine macro definition not set or duplicated
#endif

#if SPOOLDIR_V2 + SPOOLDIR_BSD42 + SPOOLDIR_BSD43 + SPOOLDIR_BNU + SPOOLDIR_ULTRIX + SPOOLDIR_TAYLOR != 1
 #error Spool directory define not set or duplicated
#endif

#if HAVE_POSIX_DIRENT + HAVE_BSD_DIRECT + HAVE_OLD_DIRECTORIES != 1
 #error No way to read directories
#endif

#if HAVE_ULTRIX_STATFS + HAVE_SCO_STATFS + HAVE_USTAT > 1
 #error Multiple disk space definitions
#endif

#ifdef PID_T
typedef PID_T pid_t;
#endif

#ifdef UID_T
typedef UID_T uid_t;
#endif

#ifdef OFF_T
typedef OFF_T off_t;
#endif

#if HAVE_BSD_TTY
#include <sgtty.h>
typedef struct sgttyb sterminal;
#define fgetterminfo(o, q) (ioctl ((o), TIOCGETP, (q)) == 0)
#define fsetterminfo(o, q) (ioctl ((o), TIOCSETN, (q)) == 0)
#endif /* HAVE_BSD_TTY */

#if HAVE_SYSV_TERMIO
#include <termio.h>
typedef struct termio sterminal;
#define fgetterminfo(o, q) (ioctl ((o), TCGETA, (q)) == 0)
#define fsetterminfo(o, q) (ioctl ((o), TCSETA, (q)) == 0)
#endif /* HAVE_SYSV_TERMIO */

#if HAVE_POSIX_TERMIOS
#include <termios.h>
typedef struct termios sterminal;
#define fgetterminfo(o, q) (tcgetattr ((o), (q)) == 0)
#define fsetterminfo(o, q) (tcsetattr ((o), TCSANOW, (q)) == 0)
#endif /* HAVE_POSIX_TERMIOS */

/* The root directory (this is needed by the system independent stuff).  */
#define ZROOTDIR "/"

/* The name of the execution directory within the spool directory.  */
#define XQTDIR ".Xqtdir"

#if HAVE_TAYLOR_CONFIG

/* The names of the configuration files.  These are appended to
   NEWCONFIGLIB which is defined in Makefile.  */
#define CONFIGFILE "/config"
#define SYSFILE "/sys"
#define PORTFILE "/port"
#define DIALFILE "/dial"
#define CALLFILE "/call"
#define PASSWDFILE "/passwd"
#define DIALCODEFILE "/dialcode"

#endif /* HAVE_TAYLOR_CONFIG */

#if HAVE_V2_CONFIG

/* The names of the various V2 configuration files.  These are
   appended to OLDCONFIGLIB which is defined in Makefile.  */
#define V2_SYSTEMS "/L.sys"
#define V2_DEVICES "/L-devices"
#define V2_USERFILE "/USERFILE"
#define V2_CMDS "/L.cmds"
#define V2_DIALCODES "/L-dialcodes"

#endif /* HAVE_V2_CONFIG */

#if HAVE_BNU_CONFIG

/* The names of the BNU configuration files.  These are appended to
   OLDCONFIGLIB which is defined in Makefile.  */
#define BNU_SYSFILES "/Sysfiles"
#define BNU_SYSTEMS "/Systems"
#define BNU_PERMISSIONS "/Permissions"
#define BNU_DIALERS "/Dialers"
#define BNU_DEVICES "/Devices"
#define BNU_PERMISSIONS "/Permissions"
#define BNU_DIALCODES "/Dialcodes"

#endif /* HAVE_BNU_CONFIG */

/* Get some standard definitions.  */

#include <sys/types.h>
#include <sys/stat.h>

/* We create files with these modes (should this be configurable?).  */
#ifdef S_IRUSR
#define IPRIVATE_FILE_MODE (S_IRUSR | S_IWUSR)
#define IPUBLIC_FILE_MODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)
#else /* ! defined (S_IRUSR) */
#define IPRIVATE_FILE_MODE (0600)
#define IPUBLIC_FILE_MODE (0644)
#endif /* ! defined (S_IRUSR) */

/* We create directories with this mode (should this be configurable?).  */
#ifdef S_IXUSR
#define IDIRECTORY_MODE (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
#define IPUBLIC_DIRECTORY_MODE (S_IRWXU | S_IRWXG | S_IRWXO)
#else /* ! defined (S_IXUSR) */
#define IDIRECTORY_MODE (0755)
#define IPUBLIC_DIRECTORY_MODE (0777)
#endif /* ! defined (S_IXUSR) */

/* The wait status stuff is complex enough that we do it in here.  I
   could create a new header file but it's too much trouble.  */

#if HAVE_SYSWAIT_H
#include <sys/wait.h>
#endif

/* We use a typedef wait_status_t for wait(2) to put results into.  We
   use SYSTEM_STATUS(i) as an lvalue to catch the return value of
   system(3).  We define the POSIX examination functions we need if
   they are not already defined (if they aren't defined, I assume that
   we have a standard wait status).  */

#if HAVE_UNION_WAIT
typedef union wait wait_status_t;
#define SYSTEM_STATUS(u) ((u).w_status)
#ifndef WIFEXITED
#define WIFEXITED(u) ((u).w_termsig == 0)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(u) ((u).w_retcode)
#endif
#ifndef WTERMSIG
#define WTERMSIG(u) ((u).w_termsig)
#endif
#else /* ! HAVE_UNION_WAIT */
typedef int wait_status_t;
#define SYSTEM_STATUS(i) (i)
#ifndef WIFEXITED
#define WIFEXITED(i) (((i) & 0xff) == 0)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(i) (((i) >> 8) & 0xff)
#endif
#ifndef WTERMSIG
#define WTERMSIG(i) ((i) & 0x7f)
#endif
#endif /* ! HAVE_UNION_WAIT */

#if HAVE_OLD_DIRECTORIES

/* Define some structures to use if we don't have opendir, etc.  */

#include <sys/dir.h>

struct dirent
{
  char d_name[DIRSIZ + 1];
};

typedef struct
{
  int o;
  struct dirent s;
} DIR;

extern DIR *opendir P((const char *zdir));
extern struct dirent readdir P((DIR *));
extern int closedir P((DIR *));

#endif /* HAVE_OLD_DIRECTORIES */

/* Information we need for a UNIX serial port.  */

struct ssysdep_serial_port
{
  /* File descriptor to read from.  */
  int oread;
  /* Whether the read descriptor is blocking.  */
  boolean fread_blocking;
  /* File descriptor to write to.  */
  int owrite;
  /* Whether the write descriptor is blocking.  */
  boolean fwrite_blocking;
  /* Hold the real read descriptor when using a dialer device.  */
  int oholdread;
  /* Hold the real write descriptor when using a dialer device.  */
  int oholdwrite;
  /* TRUE if this is a terminal and the remaining fields are valid.  */
  boolean fterminal;
  /* Baud rate.  */
  long ibaud;
  /* Original terminal settings.  */
  sterminal sorig;
  /* New terminal settings (raw mode, etc.).  */
  sterminal snew;
};

/* Information we need for a UNIX stdin port.  */

struct ssysdep_stdin_port
{
  struct ssysdep_serial_port s;
  boolean fpty;
};

/* For debugging it is helpful to know whether we are connected through
   a pty; the fsserial_read routine uses to information to know whether
   to sleep or not.  */
#define SYSDEP_STDIN_CMDS(s) \
 { "pty", CMDTABTYPE_BOOLEAN, (pointer) &(s).fpty, NULL }

#define SYSDEP_STDIN_INIT(q) ((q)->fpty = FALSE, (q)->s.oread = -1)

/* Information we need for a UNIX modem port.  */

struct ssysdep_modem_port
{
  struct ssysdep_serial_port s;
};

#define SYSDEP_MODEM_INIT(q) ((q)->s.oread = -1)

/* Information we need for a UNIX direct port.  */

struct ssysdep_direct_port
{
  struct ssysdep_serial_port s;
};

#define SYSDEP_DIRECT_INIT(q) ((q)->s.oread = -1)

/* Lock a string.  */
extern boolean fsdo_lock P((const char *, boolean fspooldir));

/* Unlock a string.  */
extern boolean fsdo_unlock P((const char *, boolean fspooldir));

/* See whether a directory exists.  */
extern boolean fsdirectory_exists P((const char *));

/* Expand a leading tilde to the public directory or a user's home
   directory.  */
extern const char *zstilde_expand P((const struct ssysteminfo *qsys,
				     const char *zfile));

/* Prepend a directory to a file name.  */
extern const char *zsappend P((const char *zdir, const char *zfile));

/* Get a temporary file name.  */
extern const char *zstemp_file P((const struct ssysteminfo *qsys));

#if SPOOLDIR_ULTRIX
/* See whether there is a spool directory for a system.  */
extern boolean fsultrix_has_spool P((const char *zsystem));
#endif /* SPOOLDIR_ULTRIX */

/* The working directory from which the program was run (this is set
   by usysdep_initialize).  */
extern char *zScwd;

/*
  Local variables:
  mode:c
  End:
  */
#endif
